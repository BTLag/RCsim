
The system runs in cycles of 3 steps
1) Post a value from somewhere specific onto the bus
2) Load a value from the bus to somewhere specific
3) Clear the bus
*The load phase will likely be two clock cycles on the hardware, one to clear the register and other to load the value of the bus to the register. (This behavior is not yet implemented in the simulation.)



Anatomy of a program byte:
ABCDEFGH
A) Whether or not the rest of the bits are an instruction (if 0) or if the rest of the bits are a 7 bit number to be posted to the bus (if 1)
B) If A is 0 then it flags if the instruction is a post (if 0) or a load (if 1). This flag can be ignored for some instructions.
C through H if A = 0) The instruction code.



Each register has its own 2 character name, the first refers to a specific circuit and the second refers to a specific register within that circuit.
Here's a list of them grouped by circuit:
Adder:
        AA = Input A of the adder       "Adder A"
        AB = Input B of the adder       "Adder B"
        AO = The result of A + B        "Adder Output"
Subtractor:	
        SA = Input A of the subtractor  "Subtractor A"
        SB = Input B of the subtractor  "Subtractor B"
        SO = The result of A - B        "Subtractor Output"
RAM:
        RA = The current address the RAM is ready to read or write to  "RAM Address"
        RV = The value of ram at the address in RA                     "RAM Value"
Program Memory:
        PA = The instruction address (write to it to jump to another part of the code)  "Program Address"
Cache:
There are four cache registers (CA,CB,CC,CD) that allow you to manipulate four numbers at once without falling back to RAM.



The intermediate language:
The language the assembler (currently called the compiler in this project) uses to generate the machine code.
It follows a very specific format where the position of each character within a line matters.
Here's an example some intermediate language generated by the following line of high level code: "01  C = A + B"
01.1: CA -> AA
01.2: CB -> AB
01.3: AO -> CC
The 1st and 2nd characters are the line number from the high level code the intermediate line is generated from.
The 3rd character is always "."
The 4th character is which step of the high level instruction the line was generated from. Each line of code in the high level language will likely take more than one line of intermediate code to complete.
The 5th and 6th characters are always ": "
The 7th and 8th characters are the name of which register should be posted to the bus UNLESS you want to post a specific number to the bus. Then the 7th character is L and the next 1 to 3 characters are the number you want to load.
    The number overwrites what would otherwise be there for the length of the number. The number's most significant digit is always the 8th character. The highest number you can load is 127. Here are a few examples:
    00.0: L1 -> CA
    00.0: L12-> CA
    00.0: L123> CA
The 8th through 11th characters are " -> " unless partially overwritten by a number.
The 12th and 13th characters are the name of which register should load the value from the bus.

The characters to the left of " -> " specify the register or value to be posted to the bus.
The characters to the right of " -> " specify the register that the bus value should be loaded to.
This is how the assembler knows if it should be posting to or loading to the specified register.



Jumping:
To jump to an arbitrary address load the address you want to jump to minus one into the PA register. The register will be incremented before the instruction at the specified address runs, so jump to the address before your target address.
If you want to jump based on a flag, load the address you want to jump to (-1) if the flag is set onto the bus. Then use one of the three conditional jump instructions:
    (JO)	Jump if the adders overflow flag is set
    (JU)	Jump if the subtractors underflow flag is set
    (J0)	Jump if SO (output of the subtractor) = 0
If the specified flag is not set, the jump instruction will be treated as a noOp and the bus will be cleared before the next instruction runs.
